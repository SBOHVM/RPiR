<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Practical 1-4: Using data frames</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="fluid-row" id="section-header">



<h1 class="title toc-ignore">Practical 1-4: Using data frames</h1>

</div>


<div id="section-overview" class="section level2">
<h2>Overview</h2>
<p><em>In this session we will start to think ahead about what kind of framework we will need when we move on to more complex models. We will build this framework (using data frames) in the context of our existing exponential growth model, and we will separate out another potentially complex element of the code – the plotting function – where we can refine it separately from the functionally important simulation code.</em></p>
</div>
<div id="section-background" class="section level2">
<h2>Background</h2>
<p>Our current model of growth of a population is held in the function <code>step_simple_growth()</code>, which has only one parameter (<code>growth.rate</code>) and one group of individuals (<code>current.population</code>). You could easily consider the amount of code and commenting that has gone into updating the latter with the former overkill.</p>
<p>However, we are developing this code knowing that we are going to be moving on to significantly more complex models with multiple parameters (<em>e.g.</em> infection rate, recovery rate), and multiple groups (<em>e.g.</em> susceptible and infected individuals), more complex ways of updating the population structure (of which more later), and more sophisticated ways of displaying the results.</p>
<p>With that in mind we are going to see how to make some of the structures in the code more general by introducing <strong>data frames</strong>, which are just R’s way of representing a table of data. Although the advantages of this are somewhat limited at the moment, they will be hopefully be clear when we move on to the epidemiological models.</p>
</div>
<div id="section-tasks" class="section level2">
<h2>Tasks</h2>
<p>The task for this practical is to replace the vector <code>population.vector</code> with a one-column <strong>data frame</strong> named <code>population.df</code> with column name <code>count</code>. We want to end up with a population update function (which we have now called <code>step_deterministic_growth()</code> for consistency with later programs) that takes in a data frame containing the current population count and the <code>growth.rate</code> parameter and outputs a data frame containing the updated count. Rewrite the code throughout so that it uses a data frame instead of a vector – we have called these files <span style="color: #de77ae;">0104-run-growth.R</span> and <span style="color: #de77ae;">0104-step-growth.R</span>. Remember to use <code>data.frame()</code> to create a data frame and <code>rbind()</code> to append one onto another.</p>
<p>So that we don’t need to worry about how to plot the outputs, we have provided a function called <code>plot_populations()</code> in the <code>RPiR</code> package which will take a data frame with any number of population columns and a single corresponding <code>time</code> column and plot them together in different colours with a legend indicating which line corresponds to which population. The RPiR package contains the function, so you will need to call <code>library(RPiR)</code> to load it. In order to use it you will need to add a column called <code>time</code> into your data frame with the times in it and then call:</p>
<pre class="r"><code>plot_populations(population.df)</code></pre>
<p>We will therefore be breaking the code into three sections <span style="color: #de77ae;">0104-run-growth.R</span>, <span style="color: #de77ae;">0104-step-growth.R</span> and the RPiR package which handle the mechanics, the model and the display respectively.</p>
<p>We’ll start by working on the function, then go on to change the main script later.</p>
<div id="section-changes-needed-to-update-0103-step-simple-growth.r-to-0104-step-growth.r" class="section level4">
<h4>Changes needed to update 0103-step-simple-growth.R to 0104-step-growth.R</h4>
<p>We’ve generated <span style="color: #de77ae;">0104-step-growth.R</span> (from <span style="color: #de77ae;">0103-step-simple-growth.R</span>) for you to edit:</p>
<pre class="r"><code>#&#39; ### Function: step_simple_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - current.population -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Return updated population
  next.population
}</code></pre>
<div id="section-step_deterministic_growth-hint">
<p><strong>Hint:</strong> See the text below for details of how to do this.</p>
</div>
<pre class="r"><code>#&#39; ### Function: step_deterministic_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - latest -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_deterministic_growth &lt;- function(latest, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * latest$count 
  # Calculate population at next timestep
  next.count &lt;- latest$count + new.additions
  # Create a data frame with the updated counts and return it
  data.frame(count = next.count) 
}</code></pre>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     grade_this(fail_code_feedback = fail_code_feedback, expr = {
##         .message &lt;- code_feedback(allow_partial_matching = allow_partial_matching)
##         if (is.null(.message)) {
##             pass(get(&quot;.__correct&quot;))
##         }
##         else {
##             fail(get(&quot;.__incorrect&quot;))
##         }
##     })(check_env)
## }
## &lt;bytecode: 0x7fb5db3b6770&gt;
## &lt;environment: 0x7fb5db8ebf28&gt;</code></pre>
<p><span style="color: #de77ae;">0104-step-growth.R</span> should contain the function doing the work in the simulation, <code>step_deterministic_growth()</code>, but with a few improvements to work in terms of a data frame rather than just a vector. So the first thing to do is change the name of the function.</p>
<p>Next, we’ll rename the argument <code>current.population</code> to <code>latest</code>, being suitably generic to work in all future models even if they are not about population dynamics.</p>
<p>We are now allowing the populations that are handled within this function to potentially contain several columns corresponding to different sets of individuals. Thus, <code>latest</code> is a data frame that contains a single row containing the latest population size for each of the component populations – in this case just the one, <code>count</code>. Therefore, to perform the update step we need to extract the actual population we are interested in. For this we use the <code>$</code> expression:</p>
<pre class="r"><code>new.additions &lt;- growth.rate * latest$count </code></pre>
<p>In general if we have a data frame called <code>my.frame</code> then <code>my.frame$first.col</code> will give us the column called <code>first.col</code>. So in our example (although we only have one column) we want to extract the column called count from the data frame called latest with the expression <code>latest$count</code> and use its value for the update step.</p>
<p>Finally, the function should return a data frame, like this:</p>
<pre class="r"><code>data.frame(count = next.count) </code></pre>
<p>which will be assigned to whatever variable in the main script we choose, in this case <code>updated.population</code>.</p>
</div>
<div id="section-changes-needed-to-update-0103-run-simple-growth.r-to-0104-run-growth.r" class="section level4">
<h4>Changes needed to update 0103-run-simple-growth.R to 0104-run-growth.R</h4>
<p>For convenience, we’ve generated <span style="color: #de77ae;">0104-run-growth.R</span> (from <span style="color: #de77ae;">0103-run-simple-growth.R</span>) for you to edit. Note that, as before, <code>source()</code> has been commented out as it won’t work in the {learnr} environment. Instead, <span style="color: #de77ae;">0103-step-simple-growth-function.R</span> and <span style="color: #de77ae;">0104-step-growth.R</span> have been preloaded for you:</p>
<pre class="r"><code>library(RPiR)

step_simple_growth &lt;- function(current.population, growth.rate) {
  new.additions &lt;- growth.rate * current.population
  next.population &lt;- current.population + new.additions
  next.population
}
  
step_deterministic_growth &lt;- function(latest, growth.rate) {
  new.additions &lt;- growth.rate * latest$count 
  next.count &lt;- latest$count + new.additions
  data.frame(count = next.count) 
}</code></pre>
<pre class="r"><code># Load the step_simple_growth() function into the global environment (my workspace)
# Note this next line would be needed if you were running this in RStudio
# source(&quot;0103-step-simple-growth-function.R&quot;)

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
human.annual.growth &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.vector &lt;- initial.count

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # Calculate population at next timestep
  updated.human.population &lt;- step_simple_growth(current.population = tail(population.vector, 1), 
                                                 growth.rate = human.annual.growth)
  # Add new element onto end of population vector
  population.vector &lt;- c(population.vector, updated.human.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
plot(c(start.time, timesteps), population.vector, type = &quot;l&quot;)</code></pre>
<p><img src="practical1-4_files/figure-html/step_simple_growth-1.png" width="672" /></p>
<pre class="r"><code>library(RPiR)
# Load the step_simple_growth() function into the global environment (my workspace)
# Note this next line would be needed if you were running this in RStudio
# source(&quot;0104-step-growth.R&quot;)

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
human.annual.growth &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.df &lt;- data.frame(count = initial.count)

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # Calculate population at next timestep
  updated.population &lt;- step_deterministic_growth(latest = tail(population.df, 1),
                                                  growth.rate = human.annual.growth) 
  # Add new element onto end of population vector
  population.df &lt;- rbind(population.df, updated.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
population.df$time &lt;- c(start.time, timesteps)
plot_populations(population.df)</code></pre>
<p><img src="practical1-4_files/figure-html/step_simple_growth-solution-1.png" width="672" /></p>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     grade_this(fail_code_feedback = fail_code_feedback, expr = {
##         .message &lt;- code_feedback(allow_partial_matching = allow_partial_matching)
##         if (is.null(.message)) {
##             pass(get(&quot;.__correct&quot;))
##         }
##         else {
##             fail(get(&quot;.__incorrect&quot;))
##         }
##     })(check_env)
## }
## &lt;bytecode: 0x7fb5db3b6770&gt;
## &lt;environment: 0x7fb5d9d8a800&gt;</code></pre>
<p>At the beginning of the file, we should load the <code>RPiR</code> package, because we’re going to be using the <code>plot_populations()</code> function that it provides, so add that in first:</p>
<pre class="r"><code>library(RPiR)</code></pre>
<p>Then read in function from the new file (though since we’re working in the {learnr} environment rather than RStudio you should comment this line out, since the file has been preloaded for you):</p>
<pre class="r"><code>source(&quot;0104-step-growth.R&quot;)</code></pre>
<p>With that done, the biggest change throughout <span style="color: #de77ae;">0104-run-growth.R</span> (and <span style="color: #de77ae;">0104-step-growth.R</span>) is that the population is now defined in terms of a data frame rather than as a vector. So setting it up will happen like this:</p>
<pre class="r"><code>population.df &lt;- data.frame(count = initial.count)</code></pre>
<p>A data frame is just R’s ways of referring to a table of data, so whereas our vector approach in the previous code would allow us to have a single list of values, the data frame will allow us to have several columns of data. Whilst this isn’t necessary for this piece of code the approach will be very useful when we are handling multiple populations (for example susceptible, infected and recovered individuals in an epidemiological model).</p>
<p>Now we want to send the latest row of the data frame to the function <code>step_deterministic_growth()</code>, which we will define below. It turns out we do that exactly the same way (using <code>tail()</code>) as we did with vectors. Notice that we have changed the name of the first parameter to something generic which will work in all future models even if they are not about population dynamics.</p>
<pre class="r"><code>updated.population &lt;- step_deterministic_growth(latest = tail(population.df, 1),
                                                growth.rate = human.annual.growth) 
population.df &lt;- rbind(population.df, updated.population)</code></pre>
<p>The second line is slightly different, however. <code>rbind()</code> binds – appends – the rows of a second data frame (<code>updated.population</code>) after the end of the last row of the first data frame (<code>population.df</code>). The two data frames must have the same columns for this to work, or they wouldn’t fit: in this case they will both have to have one column called <code>count</code>, so our function will need to return a data frame with just that column in it when we write it below. You will get a clearer idea of how the data frames work once we start on the epidemiological models with multiple populations, so don’t worry if it isn’t currently clear.</p>
<p>At the end of your new <span style="color: #de77ae;">0104-run-growth.R</span> file, rather than use R’s basic plot command plot as we did previously, we have now used a function <code>plot_populations()</code>, which is defined inside the <code>RPiR</code> library. The job of this function is to take a data frame with any number of population columns and a single corresponding <code>time</code> column and plot them together in different colours with a legend indicating which line corresponds to which population. It will allow us to ignore the plotting details for the moment.</p>
<p>In order to use it you will first need to delete the current <code>plot()</code> command at the end of your new file, and instead add a column onto your data frame with the times in and use <code>plot_populations()</code> on this updated data frame. As the <code>timesteps</code> vector is missing the start time of the simulation, the column you need to add to the data frame is actually <code>c(start.time, timesteps)</code>:</p>
<pre class="r"><code>population.df$time &lt;- c(start.time, timesteps)</code></pre>
<p>Then you will call:</p>
<pre class="r"><code>plot_populations(population.df)</code></pre>
</div>
<div id="section-additional-tasks" class="section level4">
<h4>Additional tasks</h4>
<p>Again, the code should produce the same output as the previous three practicals, but perhaps with a slightly prettier and clearer display. Try, for instance, generating a second result with different initial parameters and then plot the results using:</p>
<pre class="r"><code>plot_populations(population.df, new.graph = FALSE, col = &quot;red&quot;)</code></pre>
<p>The extra argument <code>col</code> sets the colour of the line in the plot – “red”, “blue”, etc.; or you could use <code>lty</code> to set the type of line – solid, dash, dot, etc. – by using numbers (1 is solid, 2, 3, <em>etc.</em>). Note that <code>plot_populations()</code> also has a help file, which you can access by typing <code>?plot_populations</code>:</p>
<pre class="r"><code>library(RPiR)</code></pre>
<pre class="r"><code>?plot_populations</code></pre>
<p>This documentation is available, since <code>plot_populations()</code> was installed as part of {RPiR}. When functions are loaded using <code>source()</code>, rather than being installed, then the only documentation is that in the file itself. Occasionally, you might come across a function that won’t let you ask for help using the <code>?</code> syntax – <code>?for</code>, <code>?function</code> and a couple of others. In that case you can use the <code>help()</code> function instead.</p>
<pre class="r"><code># Access the help for the &quot;function&quot; command</code></pre>
<div id="section-function_help-hint">
<p><strong>Hint:</strong> Try using <code>help("___")</code>.</p>
</div>
<pre class="r"><code>help(&quot;function&quot;)</code></pre>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     grade_this(fail_code_feedback = fail_code_feedback, expr = {
##         .message &lt;- code_feedback(allow_partial_matching = allow_partial_matching)
##         if (is.null(.message)) {
##             pass(get(&quot;.__correct&quot;))
##         }
##         else {
##             fail(get(&quot;.__incorrect&quot;))
##         }
##     })(check_env)
## }
## &lt;bytecode: 0x7fb5db3b6770&gt;
## &lt;environment: 0x7fb5dd022b00&gt;</code></pre>
<p>or go to the <span style="color: #de77ae;">Help</span> tab in RStudio and type the name into the box next to the magnifying glass.</p>
<p>As far as the <code>plot_populations()</code> function is concerned, feel free to refer back to this code later to understand better how it works by finding the code on GitHub. Or you can just run the name of the function on its own at an R prompt. We made a simpler (but less powerful) version of the plot function - <code>plot_simple()</code> - that you may find easier to read:</p>
<pre class="r"><code>library(RPiR)
plot_simple</code></pre>
<pre><code>## function (populations, new.graph = TRUE, xlim = NA, ylim = NA, 
##     lty = 1) 
## {
##     if (any(colnames(populations) == &quot;time&quot;)) {
##         time &lt;- populations$time
##         populations$time &lt;- NULL
##         if (is.na(xlim[1])) 
##             xlim &lt;- c(min(time), max(time))
##     }
##     else stop(&quot;No time info available - data frame must have a column called &#39;time&#39;&quot;)
##     labels &lt;- colnames(populations)
##     line.cols &lt;- seq_len(length(labels))
##     if (is.na(ylim[1])) 
##         ylim &lt;- c(0, max(rowSums(populations)))
##     for (index in 1:length(labels)) {
##         label &lt;- labels[index]
##         this.pop &lt;- populations[[label]]
##         if (new.graph) {
##             plot(time, this.pop, xlim = xlim, ylim = ylim, xlab = &quot;time&quot;, 
##                 ylab = &quot;population size&quot;, type = &quot;l&quot;, col = line.cols[index], 
##                 lty = lty[index])
##             graphics::legend(&quot;topright&quot;, legend = labels, lty = lty, 
##                 col = line.cols)
##             new.graph &lt;- FALSE
##         }
##         else graphics::lines(time, this.pop, col = line.cols[index], 
##             lty = lty[index])
##     }
## }
## &lt;bytecode: 0x7fb5dd5bdbb0&gt;
## &lt;environment: namespace:RPiR&gt;</code></pre>
Many of the helper functions in the course are fairly sophisticated and you will probably have to take on trust for the time being. We will be providing these functions as we go along to allow you to focus on the models being developed – you are welcome to use them yourselves later, but if you use them for real you should spend some time satisfying yourself that they really do what you want. 
<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
tutorial_options(exercise.reveal_solution = FALSE)
gradethis::gradethis_setup()

knitr::opts_chunk$set(error = TRUE)
set.seed(123)
</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.6"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/bootstrap.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.6"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.6"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.6"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.6"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79]}},"value":[{"type":"character","attributes":{},"value":["assertthat","backports","base","cachem","callr","checkmate","cli","codetools","colorspace","compiler","crayon","curl","datasets","desc","deSolve","devtools","digest","dplyr","ellipsis","evaluate","fastmap","fs","generics","ggplot2","glue","gradethis","graphics","grDevices","grid","gtable","highr","htmltools","htmlwidgets","httpuv","jsonlite","knitr","later","learnr","lifecycle","magrittr","markdown","memoise","methods","mime","munsell","pillar","pkgbuild","pkgconfig","pkgload","prettyunits","processx","promises","ps","purrr","R6","Rcpp","remotes","rlang","rmarkdown","RPiR","rprojroot","rstudioapi","scales","sessioninfo","shiny","stats","stringi","stringr","testthat","tibble","tidyselect","tools","usethis","utils","vctrs","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["0.2.1","1.2.1","4.0.3","1.0.1","3.5.1","2.0.0","2.3.0","0.2-16","2.0-0","4.0.3","1.4.0","4.3","4.0.3","1.2.0","1.28","2.3.2","0.6.27","1.0.3","0.3.1","0.14","1.1.0","1.5.0","0.1.0","3.3.3","1.4.2","0.2.0.9001","4.0.3","4.0.3","4.0.3","0.3.0","0.8","0.5.1.9000","1.5.3","1.5.5","1.7.2","1.31","1.1.0.1","0.10.1.9007","0.2.0","2.0.1","1.1","2.0.0","4.0.3","0.9","0.5.0","1.4.7","1.2.0","2.0.3","1.1.0","1.1.1","3.4.5","1.1.1","1.5.0","0.3.4","2.5.0","1.0.6","2.2.0","0.4.10","2.6","0.53.0","2.0.2","0.13","1.1.1","1.1.1","1.6.0","4.0.3","1.5.3","1.4.0","3.0.1","3.0.6","1.1.0","4.0.3","2.0.0","4.0.3","0.3.6","2.4.1","0.20","1.8-4","2.2.1"]}]}]}
</script>
<!--/html_preserve-->
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
