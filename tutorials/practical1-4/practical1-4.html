<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Practical 1-4: Using data frames</title>

<!-- HEAD_CONTENT -->

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div id="section-header">



<h1 class="title toc-ignore">Practical 1-4: Using data frames</h1>

</div>


<div id="section-overview" class="section level2">
<h2>Overview</h2>
<p><em>In this session we will start to think ahead about what kind of
framework we will need when we move on to more complex models. We will
build this framework (using data frames) in the context of our existing
exponential growth model, and we will separate out another potentially
complex element of the code – the plotting function – where we can
refine it separately from the functionally important simulation
code.</em></p>
</div>
<div id="section-background" class="section level2">
<h2>Background</h2>
<p>Our current model of growth of a population is held in the function
<code>step_simple_growth()</code>, which has only one parameter
(<code>growth.rate</code>) and one group of individuals
(<code>current.population</code>). You could easily consider the amount
of code and commenting that has gone into updating the latter with the
former overkill.</p>
<p>However, we are developing this code knowing that we are going to be
moving on to significantly more complex models with multiple parameters
(<em>e.g.</em> infection rate, recovery rate), and multiple groups
(<em>e.g.</em> susceptible and infected individuals), more complex ways
of updating the population structure (of which more later), and more
sophisticated ways of displaying the results.</p>
<p>With that in mind we are going to see how to make some of the
structures in the code more general by introducing <strong>data
frames</strong>, which are just R’s way of representing a table of data.
Although the advantages of this are somewhat limited at the moment, they
will be hopefully be clear when we move on to the epidemiological
models.</p>
</div>
<div id="section-tasks" class="section level2">
<h2>Tasks</h2>
<p>The task for this practical is to replace the vector
<code>population.vector</code> with a one-column <strong>data
frame</strong> named <code>population.df</code> with column name
<code>count</code>. We want to end up with a population update function
(which we have now called <code>step_deterministic_growth()</code> for
consistency with later programs) that takes in a data frame containing
the current population count and the <code>growth.rate</code> parameter
and outputs a data frame containing the updated count. Rewrite the code
throughout so that it uses a data frame instead of a vector – we have
called these files <span
style="color: #dd1c77;">0104-run-growth.R</span> and <span
style="color: #dd1c77;">0104-step-growth.R</span>. Remember to use
<code>data.frame()</code> to create a data frame and
<code>rbind()</code> to append one onto another.</p>
<p>So that we don’t need to worry about how to plot the outputs, we have
provided a function called <code>plot_populations()</code> in the
<code>RPiR</code> package which will take a data frame with any number
of population columns and a single corresponding <code>time</code>
column and plot them together in different colours with a legend
indicating which line corresponds to which population. The RPiR package
contains the function, so you will need to call
<code>library(RPiR)</code> to load it. In order to use it you will need
to add a column called <code>time</code> into your data frame with the
times in it and then call:</p>
<pre class="r"><code>plot_populations(population.df)</code></pre>
<p>We will therefore be breaking the code into three sections <span
style="color: #dd1c77;">0104-run-growth.R</span>, <span
style="color: #dd1c77;">0104-step-growth.R</span> and the RPiR package
which handle the mechanics, the model and the display respectively.</p>
<p>We’ll start by working on the function, then go on to change the main
script later.</p>
<div
id="section-changes-needed-to-update-0103-step-simple-growth.r-to-0104-step-growth.r"
class="section level4">
<h4>Changes needed to update 0103-step-simple-growth.R to
0104-step-growth.R</h4>
<p>We’ve generated <span
style="color: #dd1c77;">0104-step-growth.R</span> (from <span
style="color: #dd1c77;">0103-step-simple-growth.R</span>) for you to
edit:</p>
<pre class="r"><code>#&#39; ### Function: step_simple_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - current.population -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Return updated population
  next.population
}</code></pre>
<div id="section-step_deterministic_growth-hint">
<p><strong>Hint:</strong> See the text below for details of how to do
this.</p>
</div>
<pre class="r"><code>#&#39; ### Function: step_deterministic_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - latest -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_deterministic_growth &lt;- function(latest, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * latest$count 
  # Calculate population at next timestep
  next.count &lt;- latest$count + new.additions
  # Create a data frame with the updated counts and return it
  data.frame(count = next.count) 
}</code></pre>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     if (is_empty_code(check_env[[&quot;.user_code&quot;]])) {
##         return(grade_code_is_empty())
##     }
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     check_env[[&quot;.__action&quot;]] &lt;- action
##     grade &lt;- with_options(list(gradethis.allow_partial_matching = allow_partial_matching, 
##         gradethis.maybe_code_feedback = TRUE), grade_this({
##         .message &lt;- code_feedback()
##         if (is.null(.message)) {
##             if (&quot;pass&quot; %in% get(&quot;.__action&quot;)) {
##                 pass(get(&quot;.__correct&quot;))
##             }
##         }
##         else {
##             if (&quot;fail&quot; %in% get(&quot;.__action&quot;)) {
##                 fail(get(&quot;.__incorrect&quot;), hint = FALSE)
##             }
##         }
##         invisible(NULL)
##     })(check_env))
##     if (is.null(grade)) {
##         return(invisible(NULL))
##     }
##     class(grade) &lt;- c(&quot;gradethis_graded_this_code&quot;, class(grade))
##     grade
## }
## &lt;bytecode: 0x55d3accfba98&gt;
## &lt;environment: 0x55d3ae21b890&gt;</code></pre>
<p><span style="color: #dd1c77;">0104-step-growth.R</span> should
contain the function doing the work in the simulation,
<code>step_deterministic_growth()</code>, but with a few improvements to
work in terms of a data frame rather than just a vector. So the first
thing to do is change the name of the function.</p>
<p>Next, we’ll rename the argument <code>current.population</code> to
<code>latest</code>, being suitably generic to work in all future models
even if they are not about population dynamics.</p>
<p>We are now allowing the populations that are handled within this
function to potentially contain several columns corresponding to
different sets of individuals. Thus, <code>latest</code> is a data frame
that contains a single row containing the latest population size for
each of the component populations – in this case just the one,
<code>count</code>. Therefore, to perform the update step we need to
extract the actual population we are interested in. For this we use the
<code>$</code> expression:</p>
<pre class="r"><code>new.additions &lt;- growth.rate * latest$count </code></pre>
<p>In general if we have a data frame called <code>my.frame</code> then
<code>my.frame$first.col</code> will give us the column called
<code>first.col</code>. So in our example (although we only have one
column) we want to extract the column called count from the data frame
called latest with the expression <code>latest$count</code> and use its
value for the update step.</p>
<p>Finally, the function should return a data frame, like this:</p>
<pre class="r"><code>data.frame(count = next.count) </code></pre>
<p>which will be assigned to whatever variable in the main script we
choose, in this case <code>updated.population</code>.</p>
</div>
<div
id="section-changes-needed-to-update-0103-run-simple-growth.r-to-0104-run-growth.r"
class="section level4">
<h4>Changes needed to update 0103-run-simple-growth.R to
0104-run-growth.R</h4>
<p>For convenience, we’ve generated <span
style="color: #dd1c77;">0104-run-growth.R</span> (from <span
style="color: #dd1c77;">0103-run-simple-growth.R</span>) for you to
edit. Note that, as before, <code>source()</code> has been commented out
as it won’t work in the <code>learnr</code> environment. Instead, <span
style="color: #dd1c77;">0103-step-simple-growth-function.R</span> and
<span style="color: #dd1c77;">0104-step-growth.R</span> have been
preloaded for you:</p>
<pre class="r"><code>library(RPiR)

step_simple_growth &lt;- function(current.population, growth.rate) {
  new.additions &lt;- growth.rate * current.population
  next.population &lt;- current.population + new.additions
  next.population
}
  
step_deterministic_growth &lt;- function(latest, growth.rate) {
  new.additions &lt;- growth.rate * latest$count 
  next.count &lt;- latest$count + new.additions
  data.frame(count = next.count) 
}</code></pre>
<pre class="r"><code># Load the step_simple_growth() function into the global environment (my workspace)
# Note this next line would be needed if you were running this in RStudio
# source(&quot;0103-step-simple-growth-function.R&quot;)

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
human.annual.growth &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.vector &lt;- initial.count

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # Calculate population at next timestep
  updated.human.population &lt;- step_simple_growth(current.population = tail(population.vector, 1), 
                                                 growth.rate = human.annual.growth)
  # Add new element onto end of population vector
  population.vector &lt;- c(population.vector, updated.human.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
plot(c(start.time, timesteps), population.vector, type = &quot;l&quot;)</code></pre>
<p><img src="practical1-4_files/figure-html/step_simple_growth-1.png" width="672" /></p>
<pre class="r"><code>library(RPiR)
# Load the step_simple_growth() function into the global environment (my workspace)
# Note this next line would be needed if you were running this in RStudio
# source(&quot;0104-step-growth.R&quot;)

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
human.annual.growth &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.df &lt;- data.frame(count = initial.count)

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # Calculate population at next timestep
  updated.population &lt;- step_deterministic_growth(latest = tail(population.df, 1),
                                                  growth.rate = human.annual.growth) 
  # Add new element onto end of population vector
  population.df &lt;- rbind(population.df, updated.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
population.df$time &lt;- c(start.time, timesteps)
plot_populations(population.df)</code></pre>
<p><img src="practical1-4_files/figure-html/step_simple_growth-solution-1.png" width="672" /></p>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     if (is_empty_code(check_env[[&quot;.user_code&quot;]])) {
##         return(grade_code_is_empty())
##     }
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     check_env[[&quot;.__action&quot;]] &lt;- action
##     grade &lt;- with_options(list(gradethis.allow_partial_matching = allow_partial_matching, 
##         gradethis.maybe_code_feedback = TRUE), grade_this({
##         .message &lt;- code_feedback()
##         if (is.null(.message)) {
##             if (&quot;pass&quot; %in% get(&quot;.__action&quot;)) {
##                 pass(get(&quot;.__correct&quot;))
##             }
##         }
##         else {
##             if (&quot;fail&quot; %in% get(&quot;.__action&quot;)) {
##                 fail(get(&quot;.__incorrect&quot;), hint = FALSE)
##             }
##         }
##         invisible(NULL)
##     })(check_env))
##     if (is.null(grade)) {
##         return(invisible(NULL))
##     }
##     class(grade) &lt;- c(&quot;gradethis_graded_this_code&quot;, class(grade))
##     grade
## }
## &lt;bytecode: 0x55d3accfba98&gt;
## &lt;environment: 0x55d3b0f02ff0&gt;</code></pre>
<p>At the beginning of the file, we should load the <code>RPiR</code>
package, because we’re going to be using the
<code>plot_populations()</code> function that it provides, so add that
in first:</p>
<pre class="r"><code>library(RPiR)</code></pre>
<p>Then read in function from the new file (though since we’re working
in the <code>learnr</code> environment rather than RStudio you should
comment this line out, since the file has been preloaded for you):</p>
<pre class="r"><code>source(&quot;0104-step-growth.R&quot;)</code></pre>
<p>With that done, the biggest change throughout <span
style="color: #dd1c77;">0104-run-growth.R</span> (and <span
style="color: #dd1c77;">0104-step-growth.R</span>) is that the
population is now defined in terms of a data frame rather than as a
vector. So setting it up will happen like this:</p>
<pre class="r"><code>population.df &lt;- data.frame(count = initial.count)</code></pre>
<p>A data frame is just R’s ways of referring to a table of data, so
whereas our vector approach in the previous code would allow us to have
a single list of values, the data frame will allow us to have several
columns of data. Whilst this isn’t necessary for this piece of code the
approach will be very useful when we are handling multiple populations
(for example susceptible, infected and recovered individuals in an
epidemiological model).</p>
<p>Now we want to send the latest row of the data frame to the function
<code>step_deterministic_growth()</code>, which we will define below. It
turns out we do that exactly the same way (using <code>tail()</code>) as
we did with vectors. Notice that we have changed the name of the first
parameter to something generic which will work in all future models even
if they are not about population dynamics.</p>
<pre class="r"><code>updated.population &lt;- step_deterministic_growth(latest = tail(population.df, 1),
                                                growth.rate = human.annual.growth) 
population.df &lt;- rbind(population.df, updated.population)</code></pre>
<p>The second line is slightly different, however. <code>rbind()</code>
binds – appends – the rows of a second data frame
(<code>updated.population</code>) after the end of the last row of the
first data frame (<code>population.df</code>). The two data frames must
have the same columns for this to work, or they wouldn’t fit: in this
case they will both have to have one column called <code>count</code>,
so our function will need to return a data frame with just that column
in it when we write it below. You will get a clearer idea of how the
data frames work once we start on the epidemiological models with
multiple populations, so don’t worry if it isn’t currently clear.</p>
<p>At the end of your new <span
style="color: #dd1c77;">0104-run-growth.R</span> file, rather than use
R’s basic plot command plot as we did previously, we have now used a
function <code>plot_populations()</code>, which is defined inside the
<code>RPiR</code> library. The job of this function is to take a data
frame with any number of population columns and a single corresponding
<code>time</code> column and plot them together in different colours
with a legend indicating which line corresponds to which population. It
will allow us to ignore the plotting details for the moment.</p>
<p>In order to use it you will first need to delete the current
<code>plot()</code> command at the end of your new file, and instead add
a column onto your data frame with the times in and use
<code>plot_populations()</code> on this updated data frame. As the
<code>timesteps</code> vector is missing the start time of the
simulation, the column you need to add to the data frame is actually
<code>c(start.time, timesteps)</code>:</p>
<pre class="r"><code>population.df$time &lt;- c(start.time, timesteps)</code></pre>
<p>Then you will call:</p>
<pre class="r"><code>plot_populations(population.df)</code></pre>
</div>
<div id="section-additional-tasks" class="section level4">
<h4>Additional tasks</h4>
<p>Again, the code should produce the same output as the previous three
practicals, but perhaps with a slightly prettier and clearer display.
Try, for instance, generating a second result with different initial
parameters and then plot the results using:</p>
<pre class="r"><code>plot_populations(population.df, new.graph = FALSE, col = &quot;red&quot;)</code></pre>
<p>The extra argument <code>col</code> sets the colour of the line in
the plot – “red”, “blue”, etc.; or you could use <code>lty</code> to set
the type of line – solid, dash, dot, etc. – by using numbers (1 is
solid, 2, 3, <em>etc.</em>). Note that <code>plot_populations()</code>
also has a help file, which you can access by typing
<code>?plot_populations</code>:</p>
<pre class="r"><code>library(RPiR)</code></pre>
<pre class="r"><code>?plot_populations</code></pre>
<p>This documentation is available, since
<code>plot_populations()</code> was installed as part of {RPiR}. When
functions are loaded using <code>source()</code>, rather than being
installed, then the only documentation is that in the file itself.
Occasionally, you might come across a function that won’t let you ask
for help using the <code>?</code> syntax – <code>?for</code>,
<code>?function</code> and a couple of others. In that case you can use
the <code>help()</code> function instead.</p>
<pre class="r"><code># Access the help for the &quot;function&quot; command</code></pre>
<div id="section-function_help-hint">
<p><strong>Hint:</strong> Try using <code>help("___")</code>.</p>
</div>
<pre class="r"><code>help(&quot;function&quot;)</code></pre>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     if (is_empty_code(check_env[[&quot;.user_code&quot;]])) {
##         return(grade_code_is_empty())
##     }
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     check_env[[&quot;.__action&quot;]] &lt;- action
##     grade &lt;- with_options(list(gradethis.allow_partial_matching = allow_partial_matching, 
##         gradethis.maybe_code_feedback = TRUE), grade_this({
##         .message &lt;- code_feedback()
##         if (is.null(.message)) {
##             if (&quot;pass&quot; %in% get(&quot;.__action&quot;)) {
##                 pass(get(&quot;.__correct&quot;))
##             }
##         }
##         else {
##             if (&quot;fail&quot; %in% get(&quot;.__action&quot;)) {
##                 fail(get(&quot;.__incorrect&quot;), hint = FALSE)
##             }
##         }
##         invisible(NULL)
##     })(check_env))
##     if (is.null(grade)) {
##         return(invisible(NULL))
##     }
##     class(grade) &lt;- c(&quot;gradethis_graded_this_code&quot;, class(grade))
##     grade
## }
## &lt;bytecode: 0x55d3accfba98&gt;
## &lt;environment: 0x55d3b226ce68&gt;</code></pre>
<p>or go to the <span style="color: #dd1c77;">Help</span> tab in RStudio
and type the name into the box next to the magnifying glass.</p>
<p>As far as the <code>plot_populations()</code> function is concerned,
feel free to refer back to this code later to understand better how it
works by finding the code on GitHub. Or you can just run the name of the
function on its own at an R prompt. We made a simpler (but less
powerful) version of the plot function - <code>plot_simple()</code> -
that you may find easier to read:</p>
<pre class="r"><code>library(RPiR)
plot_simple</code></pre>
<pre><code>## function (populations, new.graph = TRUE, xlim, ylim, lty = 1, 
##     legend = &quot;topright&quot;) 
## {
##     if (any(colnames(populations) == &quot;time&quot;)) {
##         time &lt;- populations$time
##         populations$time &lt;- NULL
##     }
##     else stop(&quot;No time info available - data frame must have a column called &#39;time&#39;&quot;)
##     labels &lt;- colnames(populations)
##     line.cols &lt;- seq_along(labels)
##     if (missing(xlim)) 
##         xlim &lt;- c(min(time), max(time))
##     if (missing(ylim)) 
##         ylim &lt;- c(0, max(rowSums(populations)))
##     for (index in seq_along(labels)) {
##         label &lt;- labels[index]
##         this.pop &lt;- populations[[label]]
##         if (new.graph) {
##             plot(time, this.pop, xlim = xlim, ylim = ylim, xlab = &quot;time&quot;, 
##                 ylab = &quot;population size&quot;, type = &quot;l&quot;, col = line.cols[index], 
##                 lty = lty[index])
##             graphics::legend(legend, legend = labels, lty = lty, 
##                 col = line.cols, box.lty = 0, inset = 0.02)
##             new.graph &lt;- FALSE
##         }
##         else graphics::lines(time, this.pop, col = line.cols[index], 
##             lty = lty[index])
##     }
## }
## &lt;bytecode: 0x55d3b24d7538&gt;
## &lt;environment: namespace:RPiR&gt;</code></pre>
<p>Many of the helper functions in the course are fairly sophisticated
and you will probably have to take on trust for the time being. We will
be providing these functions as we go along to allow you to focus on the
models being developed – you are welcome to use them yourselves later,
but if you use them for real you should spend some time satisfying
yourself that they really do what you want. 
<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
tutorial_options(exercise.reveal_solution = FALSE)
gradethis::gradethis_setup()

knitr::opts_chunk$set(error = TRUE)
set.seed(123)
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.18"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.18"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/bootstrap.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.18"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.18"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.18"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86]}},"value":[{"type":"character","attributes":{},"value":["backports","base","bslib","cachem","callr","checkmate","cli","codetools","colorspace","commonmark","compiler","crayon","curl","datasets","deSolve","devtools","digest","dplyr","ellipsis","evaluate","fansi","fastmap","fs","generics","ggplot2","glue","gradethis","graphics","grDevices","grid","gtable","here","highr","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","learnr","lifecycle","magrittr","markdown","memoise","methods","mime","miniUI","munsell","pillar","pkgbuild","pkgconfig","pkgload","prettyunits","processx","profvis","promises","ps","purrr","R6","Rcpp","remotes","rlang","rmarkdown","RPiR","rprojroot","rstudioapi","sass","scales","sessioninfo","shiny","stats","stringi","stringr","tibble","tidyselect","tools","urlchecker","usethis","utf8","utils","vctrs","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.4.1","4.2.2","0.4.1","1.0.6","3.7.3","2.1.0","3.4.1","0.2-18","2.0-3","1.8.1","4.2.2","1.5.2","4.3.3","4.2.2","1.34","2.4.5","0.6.30","1.0.10","0.3.2","0.18","1.0.3","1.1.0","1.5.2","0.1.3","3.4.0","1.6.2","0.2.11.9000","4.2.2","4.2.2","4.2.2","0.3.1","1.0.1","0.9","0.5.3","1.5.4","1.6.6","0.1.4","1.8.4","1.41","1.3.0","0.11.2.9000","1.0.3","2.0.3","1.4","2.0.1","4.2.2","0.12","0.1.1.1","0.5.0","1.8.1","1.4.0","2.0.3","1.3.2","1.1.1","3.8.0","0.3.7","1.2.0.1","1.7.2","0.3.5","2.5.1","1.0.9","2.4.2","1.0.6","2.18","0.76.22","2.0.3","0.14","0.4.4","1.2.1","1.2.2","1.7.3","4.2.2","1.7.8","1.5.0","3.1.8","1.2.0","4.2.2","1.0.1","2.1.6","1.2.2","4.2.2","0.5.1","2.5.0","0.35","1.8-4","2.3.6"]}]}]}
</script>
<!--/html_preserve-->
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
