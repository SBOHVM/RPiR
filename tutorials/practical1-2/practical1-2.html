<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Practical 1-2: Functional model</title>

<!-- HEAD_CONTENT -->

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div id="section-header">



<h1 class="title toc-ignore">Practical 1-2: Functional model</h1>

</div>


<div id="section-overview" class="section level2">
<h2>Overview</h2>
<p><em>In this session you will break the program 0101-growth-loop.R into two conceptually distinct parts – moving the code implementing how the population behaves into a function, thus separating it from the mechanics of running the simulation and plotting the results.</em></p>
</div>
<div id="section-introduction" class="section level2">
<h2>Introduction</h2>
<p>When we look at our first program (for convenience, <span style="color: #dd1c77;">0101-growth-loop.R</span> is printed below), there are several distinct parts to the code, despite its brevity. We first set the initial conditions of the simulation, then we run the simulation itself, and finally we plot the output.</p>
<pre class="r"><code>#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
growth.rate &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.vector &lt;- initial.count

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # First extract the current population size
  current.population &lt;- tail(population.vector, 1)
  # Calculate changes to population (births)
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Add new element onto end of population vector
  population.vector &lt;- c(population.vector, next.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
plot(c(start.time, timesteps), population.vector, type = &quot;l&quot;)</code></pre>
<p><img src="practical1-2_files/figure-html/plot-1.png" width="672" /></p>
<p>Inside the simulation, we have the mechanics of iterating over the timesteps and keeping track of the results, and there is the implementation of the growth model itself, which occurs inside the curly brackets. Obviously in this case none of these four steps are very complex (and you indeed might decide there are fewer – or even more – that are actually important), but as we develop more complex models some or all of them will become more complicated, and if they are all written out in one continuous piece of code it will become harder and harder to work out where one part ends and another begins, and how we need to change the code if we want, for instance, to change the underlying model of population growth, but not change the technique used for simulation or the plots produced, in the same way as you might wish this paragraph had been broken into sentences instead of running on seemingly for ever!</p>
<p>What we need to do is to introduce exactly the computing equivalent of punctuation and sentence/paragraph structure into the code. We introduce this partly by <strong>commenting the code</strong> well, which we have already started to do, but mostly by <strong>separating out conceptually distinct parts of the code into</strong> <strong>separate functions</strong>. This process will continue through the whole course as we identify reusable pieces of code that we can get right once, and then (hopefully) never have to worry about again. This often turns out to be more of an aspiration than reality, but nonetheless, when we do want to improve specific parts of our models, it is much easier to do it when the code is well structured.</p>
</div>
<div id="section-tasks" class="section level2">
<h2>Tasks</h2>
<p>Look at <span style="color: #dd1c77;">0101-growth-functional.R</span>. The code in the for loop, that is to say inside the curly brackets, describes the way that the population changes from one point in time to the next. This (together with, perhaps, the starting conditions) is what we would be changing if we wanted to explicitly introduce birth and death into the model, or make it a model of disease spread rather than population growth. The rest would remain pretty much the same.</p>
<p>We want to take this code and put it into its own function at the beginning of the program – we’ll call it <code>step_simple_growth()</code>. You can learn more about functions in <span style="color: #dd1c77;">Practical A-2</span>. It should take the current population count from the vector <code>population.vector</code> and the value of <code>growth.rate</code> as <strong>arguments</strong> (function inputs), update the population size, and return it. This is the framework for such a function with comments (try to fill it in, using the for loop in <span style="color: #dd1c77;">0101-growth-loop.R</span> as a guide):</p>
<pre class="r"><code>#&#39; ### Function: step_simple_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - current.population -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- ___
  # ___
  next.population &lt;- ___
  # Return updated population
  next.population
}</code></pre>
<pre><code>## Error: &lt;text&gt;:13:20: unexpected input
## 12:   # Calculate changes to population
## 13:   new.additions &lt;- _
##                        ^</code></pre>
<pre class="r"><code>step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Return updated population
  next.population
}</code></pre>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     grade &lt;- with_options(list(gradethis.allow_partial_matching = allow_partial_matching, 
##         gradethis.maybe_code_feedback = TRUE), grade_this({
##         .message &lt;- code_feedback()
##         if (is.null(.message)) {
##             pass(get(&quot;.__correct&quot;))
##         }
##         fail(get(&quot;.__incorrect&quot;))
##     })(check_env))
##     class(grade) &lt;- c(&quot;gradethis_graded_this_code&quot;, class(grade))
##     grade
## }
## &lt;bytecode: 0x7ff939ee4cd8&gt;
## &lt;environment: 0x7ff939ee74b8&gt;</code></pre>
<p>The <code>function()</code> command, like <code>for()</code>, has one line of code after it (comments are ignored) that defines what the function does. Because nearly all functions need multiple lines to define what they do, we nearly always use <code>{ ... }</code> syntax (as with <code>for()</code>) to allow us to write multiple commands all as part of the function definition. Remember that <strong>whatever appears last in the function</strong> <strong>definition will be returned to the script that calls it</strong>, in this case <code>next.population</code>.</p>
<p>To make sure that the function is only using the information given to it in its arguments, we are going to use <code>findGlobals()</code> to check that it does not use any external information (known as <strong>global variables</strong>). To do this we load in the codetools library (you may have to install it first), and then call the <code>findGlobals()</code> function giving it the name of our function, as follows:</p>
<pre class="r"><code>step_simple_growth &lt;- function(current.population, growth.rate) {
  new.additions &lt;- growth.rate * current.population
  next.population &lt;- current.population + new.additions
  next.population
}</code></pre>
<pre class="r"><code>library(codetools) 
findGlobals(step_simple_growth, merge=FALSE)</code></pre>
<pre><code>## $functions
## [1] &quot;{&quot;  &quot;*&quot;  &quot;+&quot;  &quot;&lt;-&quot;
## 
## $variables
## character(0)</code></pre>
<p>This will return some built in functionality of R which your function uses under “functions”, and then hopefully nothing under variables (it actually says <code>character(0)</code>, which is code speak for “exit success”).</p>
<p>Note that the objects <code>new.additions</code> and <code>next.population</code> remain internal to the function <code>step_simple_growth()</code> and have no effect on the main script. <strong>Objects within a function exist seperately from those in the main script and only exist for the length of time the function is run</strong> (see <code>my_function()</code> below). We could call them <code>x</code> and <code>y</code> if we wanted to, it doesn’t matter. What is important, is the name that we assign to the output of the function in the main script, which in this case (as we shall shortly see) is also <code>next.population</code>. This reuse of names is slightly confusing, but doesn’t affect the running of the code. For clarity, however, we’ll rename these objects later (don’t worry about them right now).</p>
<p>Try playing with the following code chunk. Add a print statement inside <code>my_function()</code>, then add a print statement after calling <code>my_function()</code> in the main script, and compare the value of <code>x</code>. Make sure you understand what is happening.</p>
<pre class="r"><code># Simple function that adds 1 to an input
my_function &lt;- function(input) {
  x &lt;- input + 1
  x
}

# Test the function
val &lt;- 10
my_function(val)</code></pre>
<pre><code>## [1] 11</code></pre>
<pre class="r"><code>my_function(val * 2)</code></pre>
<pre><code>## [1] 21</code></pre>
<pre class="r"><code>x &lt;- 1
my_function(x)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>my_function((x + 1) * 2)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>new.value &lt;- 3
my_function(input = new.value)</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code># Simple function that adds 1 to an input
my_function &lt;- function(input) {
  x &lt;- input + 1
  print(x)
  x
}

# Test the function
x &lt;- 10
my_function(x)</code></pre>
<pre><code>## [1] 11</code></pre>
<pre><code>## [1] 11</code></pre>
<pre class="r"><code>print(x)</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Having now defined the <code>step_simple_growth()</code> function, the code should proceed much as before but rather than have a chunk of code inside the loop we can just assign the output of the function <code>step_simple_growth()</code> to the <code>next.population</code> object (replacing the first three lines of code in the <code>for()</code> loop with one line of code). Try it now and then run the code again, comparing the plotted outputs to check that your new code works exactly as the old version did (but structured in a better style):</p>
<pre class="r"><code>#&#39; ### Function: step_simple_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - current.population -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Return updated population
  next.population
}

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
growth.rate &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.vector &lt;- initial.count

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # ___
  next.population &lt;- ___
  # Add new element onto end of population vector
  population.vector &lt;- c(population.vector, next.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
plot(c(start.time, timesteps), population.vector, type = &quot;l&quot;)</code></pre>
<pre><code>## Error: &lt;text&gt;:47:22: unexpected input
## 46:   # ___
## 47:   next.population &lt;- _
##                          ^</code></pre>
<pre class="r"><code>#&#39; ### Function: step_simple_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - current.population -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Return updated population
  next.population
}

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
growth.rate &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.vector &lt;- initial.count

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # Calculate population at next timestep
  next.population &lt;- step_simple_growth(current.population = tail(population.vector, 1), 
                                        growth.rate = growth.rate)
  # Add new element onto end of population vector
  population.vector &lt;- c(population.vector, next.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
plot(c(start.time, timesteps), population.vector, type = &quot;l&quot;)</code></pre>
<p><img src="practical1-2_files/figure-html/nextstep-solution-1.png" width="672" /></p>
<pre class="r"><code>grade_this_code()</code></pre>
<pre><code>## function (check_env) 
## {
##     check_env[[&quot;.__correct&quot;]] &lt;- correct
##     check_env[[&quot;.__incorrect&quot;]] &lt;- incorrect
##     grade &lt;- with_options(list(gradethis.allow_partial_matching = allow_partial_matching, 
##         gradethis.maybe_code_feedback = TRUE), grade_this({
##         .message &lt;- code_feedback()
##         if (is.null(.message)) {
##             pass(get(&quot;.__correct&quot;))
##         }
##         fail(get(&quot;.__incorrect&quot;))
##     })(check_env))
##     class(grade) &lt;- c(&quot;gradethis_graded_this_code&quot;, class(grade))
##     grade
## }
## &lt;bytecode: 0x7ff939ee4cd8&gt;
## &lt;environment: 0x7ff9399d65c8&gt;</code></pre>
<pre class="r"><code># Within the `for()` loop where the time gets updated the code should be edited
# to contain the line and an appropriate comment:

next.population &lt;- step_simple_growth(current.population = tail(population.vector, 1), 
                                      growth.rate = growth.rate)</code></pre>
<p>Note that we always set arguments to functions with <code>argument = value</code>, and we strongly recommend using <code>object &lt;- value</code> to set variables in your main script to make the distinction clear. For example, <code>current.population</code> is now an argument of the <code>step_simple_growth()</code> function, and so you set its value using <code>=</code> inside the function call instead of using <code>&lt;-</code> in the main script as we did on line 28 of <span style="color: #dd1c77;">0101-growth-functional.r </span>.</p>
<p>When you are happy with the code and its outputs there is another task. If you look at the whole code, you will see that <code>growth.rate</code> is both the name of the argument in the function and the name of the variable in the script, and <code>next.population</code> is used in the function and in the main script. As we said above, this does not affect the running of the code but can be difficult to read and can result in confusion when debugging for example.</p>
<p>Here’s the latest version of the code to play with (<span style="color: #dd1c77;">0102-growth-functional.R</span>), complete with the <code>step_simple_growth()</code> function:</p>
<pre class="r"><code>#&#39; ### Function: step_simple_growth() 
#&#39; Run one step of a simple deterministic exponential growth model. 
#&#39;
#&#39; Arguments: 
#&#39; - current.population -- the population count now
#&#39; - growth.rate -- the growth rate 
#&#39;
#&#39; Returns:
#&#39; - the updated population count
#&#39;
step_simple_growth &lt;- function(current.population, growth.rate) {
  # Calculate changes to population
  new.additions &lt;- growth.rate * current.population
  # Calculate population at next timestep
  next.population &lt;- current.population + new.additions
  # Return updated population
  next.population
}

#&#39; Set up the simulation parameters
#&#39; --------------------------------
#&#39; First we set up the parameters for the simulation.

# Set the growth rate
growth.rate &lt;- 0.015

# Starting population size
initial.count &lt;- 7000000000

# And setting times
start.time &lt;- 0
end.time &lt;- 100

#&#39; Run the simplest possible simulation
#&#39; ------------------------------------
#&#39; Then run it so that we can get the output we need

# Set up the population starting size (at the first timestep)
population.vector &lt;- initial.count

# The timesteps that the simulation will run through
timesteps &lt;- seq(from = start.time + 1, to = end.time)

# Now we loop through the time itself (starting at the second timestep)
for (new.time in timesteps) {
  # Calculate population at next timestep
  next.population &lt;- step_simple_growth(current.population = tail(population.vector, 1), 
                                        growth.rate = growth.rate)
  # Add new element onto end of population vector
  population.vector &lt;- c(population.vector, next.population)
}

#&#39; Plot the results
#&#39; ----------------
#&#39; And finally we output the results.

# Now we can plot the timesteps against the population vector
plot(c(start.time, timesteps), population.vector, type = &quot;l&quot;)</code></pre>
<p><img src="practical1-2_files/figure-html/laststep-1.png" width="672" /></p>
<p>Find all the instances of <code>growth.rate</code> and replace them with <code>my.rate</code> in the <code>step_simple_growth()</code> function (lines 11-18), then run the code. What happens? You should get an error. It will tell you that you have an unused argument, <code>growth.rate</code> when you call <code>step_simple_growth()</code>. This is because when you call the function (lines 47-48), you set its <code>growth.rate</code> argument to the main script’s value of <code>growth.rate</code>, but the function now only has an argument called <code>my.rate</code> (line 11). To fix this, we can change the call to <code>step_simple_growth()</code> to say <code>my.rate = growth.rate</code> (line 48), remembering to . Now rerun the code and check it works.</p>
<p>Now do the same with <code>next.population</code>, replacing it <strong>just in the function</strong> with <code>my.population</code>, or something sensible, then run the code. What happens? You should find that the model runs exactly as before this time. This is because none of the names of objects being used in the function matter – even if their values are being returned to the main script. Object names and values are thrown away when the function finishes. Only the objects in the main script are retained. The only thing that matters is that object names are used consistently within the function, and when you call the function in the main script.</p>
<p>We need to use meaningful names to remind us what we are doing, but it can be confusing and cause subtle errors if we use the same variable names in many different places, even when they seem to refer to the same things. This is one of the reasons why we use <code>findGlobals()</code> to check for global variables being used in functions. If we never reused names in different bits of code we would not have to check this. For the time being (and the rest of this practical series), make sure that no argument names in the main script accidentally match names in functions (it’s okay for variable names in different functions to match). You can relax this requirement in the real world, but it is best to be over-cautious for the time being.</p>
For this practical, we are working with the human population in the script, so in the following exercises we’ll change the <code>growth.rate</code> variable (in the main script) to <code>human.annual.growth</code>, and change <code>next.population</code> (in the main script) to <code>updated.human.population</code>. 
<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
tutorial_options(exercise.reveal_solution = FALSE)
gradethis::gradethis_setup()

knitr::opts_chunk$set(error = TRUE)
set.seed(123)
</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/bootstrap.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.11"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]}},"value":[{"type":"character","attributes":{},"value":["backports","base","bslib","checkmate","codetools","compiler","curl","datasets","digest","ellipsis","evaluate","fastmap","gradethis","graphics","grDevices","highr","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","learnr","lifecycle","magrittr","markdown","methods","mime","promises","R6","Rcpp","rlang","rmarkdown","rprojroot","sass","shiny","stats","stringi","stringr","tools","utils","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.4.0","4.1.2","0.3.1","2.0.0","0.2-18","4.1.2","4.3.2","4.1.2","0.6.29","0.3.2","0.14","1.1.0","0.2.4.9000","4.1.2","4.1.2","0.9","0.5.2","1.5.4","1.6.3","0.1.4","1.7.2","1.36","1.3.0","0.10.1.9017","1.0.1","2.0.1","1.1","4.1.2","0.12","1.2.0.1","2.5.1","1.0.7","0.4.12","2.11","2.0.2","0.4.0","1.7.1","4.1.2","1.7.6","1.4.0","4.1.2","4.1.2","2.4.3","0.28","1.8-4","2.2.1"]}]}]}
</script>
<!--/html_preserve-->
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
