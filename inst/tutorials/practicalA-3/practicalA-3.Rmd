---
title: "Practical A-3: Functions and naming of things"
output:
  learnr::tutorial:
    theme: lumen
    includes:
      in_header: !expr system.file("tutorials/google-font.html", package = "RPiR")
runtime: shiny_prerendered
description: >
  Revision of basic concepts.
---

```{r setup, include=FALSE}
library(learnr)
tutorial_options(exercise.reveal_solution = FALSE)
gradethis::gradethis_setup()

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">",
  error = TRUE
)
set.seed(123)
```

## Functions

Just as loops allow you to repeat the same code chunk again and again in one
place, functions allow you to repeat the same task multiple times, but
potentially in multiple places on different data. If you have a complex piece
of code that does a single discrete thing, then you may want to wrap it up
into a function so that you can refer to it by a simple name and keep the
script that calls it clear and easy to read.

To quote from [the introduction to R4DS on functions][functions-R4DS]:

> One of the best ways to improve your reach as a data scientist is to write functions. Functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting. Writing a function has three big advantages over using copy-and-paste:
>
> 1. You can give a function an evocative name that makes your code easier to understand.
>
> 2. As requirements change, you only need to update code in one place, instead of many.
>
> 3. You eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).

Functions allow us to wrap up a common task into a single line of code,
irrespective of how complex and long the code chunk is, making our scripts 
cleaner and easier to read. They allow us to describe what the code is doing 
(by assigning a name to the function), making our scripts easier to understand. 
Finally, writing custom functions rather than duplicating code means that there 
is only a single place that needs to be checked for correctness, rather than 
having to remember all of the places your duplicated (likely copied and pasted) 
code exists.

It's very easy to write a function. Here we write a single function
(called `function_name`), that takes one input (we call the inputs to
functions *arguments*, here there is just one called `argument`). Finally,
whatever appears last in the function definition will be returned to the script
that calls it, in this case, `result`.

Every function has one "line" of code after it (comments are ignored) that
defines what the function does. Because nearly all functions need multiple lines
to define what they do, we nearly always use matching curly brackets - `{ ... }` -
to allow us to wrap multiple commands that are all treated as one line by R:

```{r intro1, eval=FALSE}
function_name <- function(argument) {
  # Function body
  
  # ... exciting code using argument
  #     to do something useful, and
  #     producing some result ...
  result
}
```

Above, we just have dummy code, and it doesn't work. Note that the *function
body*, the code that gets run when you use the function is wrapped in curly
brackets `{ ... }` - this makes it possible for the computer to know what is
supposed to be in the function and what isn't.

Now we can write a couple of very simple functions that really do
something (not very exciting!):

```{r simple, exercise.cap = "Example 1", exercise=TRUE}
add_one <- function(number) {
  number + 1
}

add_one(10)
```

Try running the code block. Can you see what it does? Feel free to change the 
argument from `10` to a different value to make
sure it works as expected. And change what the function does if you like -
when you do, change the name though, so it makes sense... it's really important
for your functions to have good names so it's easy to tell if you're using them
right. Note that because `add_one(10)` is called after you close the curly 
bracket, it's not considered part of the function, it's in your main script.

The last (and indeed only) line of code in this function is what is returned by
the function, here just the number plus one. **It's critical that the
last line of your function has the value you want to return in it.** Normally we
need to do something more complex in our function - here we make a calculation
and then return it on the last line (possibly the second simplest thing we
could do):

```{r multiple, exercise.cap = "Example 2", exercise=TRUE}
add_one <- function(number) {
  one.more <- number + 1
  one.more
}

add_one(10)
```

Check that this does the same job. *Example 1* may seem simpler. However, it's
usually helpful when writing functions to name the thing that you calculate to
make it easier to keep track of what's going on. You can then return the
variable (in *Example 2*, `one.more`) that you have just calculated.

Try running the next example:

```{r error, exercise.cap = "Exercise 1", exercise=TRUE}
add_one <- function(number) {
  one.more <- number + 1
  one.more
}

add_one(10)
one.more
```

```{r error-solution}
add_one <- function(number) {
  one.more <- number + 1
  one.more
}

one.more <- 20
add_one(10)
one.more
```

```{r error-check}
grade_this_code()
```

You'll see that it gives an error. That is because, although you have calculated
`one.more` inside the function, it is discarded when the function ends. This is
because variables defined inside functions are *local* to the function.
For there to be a variable in your main script called one.more, you need to
define it there. Try adding a line of code between lines 5 and 6 of *Exercise 1*
that just says:

```{r, eval=FALSE}
one.more <- 20
```

Note that the *global* `one.more` variable (the one in your main script) is not
affected by calling the `add_one()` function even though it looks like it is
updated there.

## Naming of things

### Dots and underscores

You may have noticed that my functions were called
things like `add_one` (with an underscore), but my variables had names like
`one.more` (with a dot). This was deliberate. Variables and functions should be
made up of one or more words (or abbreviations) to make it easy to understand
what they do. However, it can be hard to read names just stuck together like
`addtwonumberstogether`, whereas `add_two_numbers_together` is easier.
However, there are boring reasons to do with how R works why it's a bad idea to
write R functions with dots in their names (even though many functions in R
already have dots). As a result, in these practicals, I insist that you don't
uses dots in function names when you write them.

However, dots are generally okay in variables names, so to make it easy to
distinguish normal variables from functions, I choose to put dots in variable
names (as `one.more`). You can do whatever you like.

Here's a function that takes two arguments and adds them together (yes, it
is just reinventing `+`!):

```{r rename, exercise.cap = "Exercise 2", exercise=TRUE}
add.up <- function(first, second) {
  added_together <- first + second
  added_together
}

add.up(10, 30)
```

```{r rename-solution}
add_up <- function(first, second) {
  added.together <- first + second
  added.together
}

add_up(10, 30)
```

```{r rename-check}
grade_this_code()
```

Rename the function and variables in *Exercise 2* so that it satisfies my
naming rules.

*There is much more on how to style your code to make it more consistent
[here](http://adv-r.had.co.nz/Style.html). Hadley recommends never using dots,
so using underscores to separate words in functions and variables. If you want
to do that it's fine. Don't use dots in function names though. He has lots of
other suggestions about how to write clear code - do have a look at it and try
to follow it if you have time.*

### Not reusing names

In *Exercise 1*, we showed that variables used in functions don't affect what
happens outside the function. Unfortunately, the reverse isn't true. Look at
this function:

```{r global, exercise.cap = "Exercise 3", exercise=TRUE}
missing_add <- function(first) {
  first + second
}

missing_add(10)
```

This function was intended to be like `add_up()` in *Exercise 2*, but I
accidentally forgot to add the second argument. Fortunately if you run it, it
will give an error (try it). However, what happens if you have defined
a variable called `second` elsewhere in your script? Try adding the following
at line 4:

```{r, eval=FALSE}
second <- 1
```

`missing_add(10)` should no longer give an error, and return `11`. Try changing
`second` to 2 - `missing_add(10)` should now return `12`. That's not good news -
what the function does depends on what else you may have done in your script.
When you call a function it should always do the same if you give it the same
arguments.

This gets even worse when you account for our ability to misspell things:

```{r misspelling, exercise.cap = "Exercise 4", exercise=TRUE}
misspelled_add <- function(first, second) {
  resuIt <- first + second
  result
}

result <- -5
misspelled_add(10, 20)
misspelled_add(1, 2)
```

<div id="misspelling-hint">
**Hint:** If you can't see the problem see how the word `result` is spelled in
different places.
</div>

You should find that `misspelled_add()` gives the wrong answer even though the
code looks right (if you don't look too closely). This problem can (and does!)
cause hours of agony to some students every year on this course. As a result,
we insist on two things in your submitted practicals:

1. You use different variable names in your functions than in your scripts,
   wherever possible. Sometimes there really only is one sensible name
   for a variable (maybe `timestep` when describing the increments in your
   simulation model), and you should be very careful when that happens, but
   normally there are at least two ways of describing the same idea - often one
   more general in a function (`birth.rate`) which can be used in multiple
   contexts, and then specific in your main script each time you use it
   (`human.annual.birth.rate`, for instance).
2. You write checks for your functions to make sure they aren't accidentally
   missing any variables or arguments. There are two tools for this,
   `findGlobals()` and `checkUsage()` in the `codetools` library.

Try adding the following lines to the end of *Exercise 4*:

```{r, eval=FALSE}
library(codetools)
checkUsage(misspelled_add)
```

You'll see that it reports on the problem that you have probably already
identified. It can also identify other problems, and we recommend it to you.
However, it doesn't return anything you can use in your code to allow us to
automatically reject bad functions, and we'll show you how to do this in a
later practical. For now just try using this line instead of `checkUsage()`
above (the `library()` call is the same):

```{r, eval=FALSE}
findGlobals(misspelled_add, merge = FALSE)
```

You'll see that it identifies the use of the global variable `result` too
(if less elegantly). We'll show you how to use this to automatically detect
problems with variable misnaming in a later exercise, but for now just remember
that you need to watch out for misspelling very carefully.

*If you're interested, the `findGlobals()` output also tells you why this
problem exists in R. You'll see that the function `misspelled_add()` needs
to use three other *global* variables - the functions `{`, `+` and `<-` - to get
the function to work. As a result of the way R works, functions have to be able
to see what is going on outside to be able to work at all. Most languages handle
this more elegantly.*

Functions are covered in R4DS [here][functions-R4DS] and R Coder covers
them in some depth [here][functions-rcoder]. Advanced R covers functions in
enormous detail starting [here][functions-advanced-r2] with an introduction to
functional programming, and continuing for several chapters.

[functions-R4DS]: https://r4ds.had.co.nz/functions.html
[functions-advanced-r2]: https://adv-r.hadley.nz/fp.html
[functions-rcoder]: https://r-coder.com/function-r

## Exercises

Here are a few more examples for you to try. This first example is intended to 
subtract two numbers, returning the calculated value, whilst also checking 
whether or not the result is negative. Try to fix the mistake in the code.

```{r, functionexercise, exercise.cap = "Exercise 5", exercise = TRUE}
subtract <- function(first, second) {
  # Calculate the result
  subtracted <- first - second
  # And return it
  subtracted
  # Check whether result is negative
  if (subtracted < 0) 
    print("Negative number")
}

# Call the function to subtract 5 from 3
subtract(3, 5)
```

```{r, functionexercise-solution}
subtract <- function(first, second) {
  # Calculate the result
  subtracted <- first - second
  # Check whether result is negative
  if (subtracted < 0) 
    print("Negative number")
  # And return it
  subtracted
}

# Call the function to subtract 5 from 3
subtract(3, 5)
```

```{r functionexercise-check}
grade_this_code()
```
